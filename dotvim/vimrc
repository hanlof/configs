" TODO:s
" remove bang from <F9> mapping? hmm....
" sort out the githash checking and formatting/coloring/compilation
"  options depending on git repo and path and file-type
" where to store custom compiler 'plugins'?
" - compiler configs are sort-of repo- or project-specific
" - keep them on github or not?
" automatic tags generation??
" more serious cscope usage??
" some colors improvements are still only in gvimrc
" how to do mouse-browsing in console-mode?
" - Ctrl-Click is lock[220zed by xterm-menu (if even detectable)
"   Maybe use g<LeftMouse> for jumping to tag??
" - Buttons for :tnext/:tprev does not work

" Mouse browsing features (wishlist)
" Jump to tag
"  tnext / tprev
" Search for word
" Toggle :cwin
" Git grep
" Git blame
" gD / gd (goto definition)

" this old friend gets a special place in dotvimrc :-D
set nocp

let rtcmd="set runtimepath+=" . expand("<sfile>:h")
let g:gvimrcpath=expand("<sfile>:h") . "/gvimrc"
exec rtcmd
exec rtcmd . "/../submodules/vim-fugitive"
exec rtcmd . "/../submodules/vim-bitbake"
exec rtcmd . "/../submodules/vim-clang"

runtime ftplugin/man.vim

au GuiEnter * exec "source " . g:gvimrcpath

set laststatus=2
set ruler
set statusline=%<%f\ %h%m%r%=%n\ %-14.(%l,%c%V%)\ %P
set showcmd

set backspace=2

set splitright

" enable syntax-sensitive folding
set foldmethod=syntax foldcolumn=2 foldlevel=10

" search is case insensitive unless the search pattern contains capital letters
set ignorecase smartcase

" vims defaults are mostly sane but for switch cases we must let it know whats correct
set cinoptions=l1

set mouse=a
set sessionoptions+=resize,localoptions
set autowrite
set wildmenu

set listchars=tab:â€£\ 
set list

set cscopequickfix=s-,c-,d-,i-,t-,e-

" syntax plugin options
let g:is_bash = 1
let g:load_doxygen_syntax = 1

" clang plugin options
let g:clang_auto=0
let g:clang_verbose_pmenu=1
let g:clang_c_completeopt="longest,menuone,preview"

syn on

if $TERM == "xterm-256color"
  colorscheme siennaterm
endif

" output '<CSI>5 q' (set cursor to non-blinking solid block) when exiting insert-mode
let &t_EI="\<Esc>[2 q"
" output '<CSI>5 q' (set cursor to blinking bar) when entering insert-mode
let &t_SI="\<Esc>[5 q"
" timeout for waiting for complete key-codes from terminal.
" the default value is 1000 which makes vim wait a full second from pressing
" escape until it exits insert-mode. this in turn makes the updating of the
" cursor really slow.
set timeout timeoutlen=5000 ttimeout ttimeoutlen=20

filetype on
filetype plugin on
filetype indent on

" Stuff that we always want to do when a new window is created
au VimEnter * call g:InitWindow()
au WinEnter * call g:InitWindow()
function! g:InitWindow()
  if exists('w:is_initialised')
    return
  endif
  let w:is_initialised = 1

  call matchadd("Error", "\\s\\+$") " whitespace at EOL is bad
  call matchadd("Error", " \\+\t")  " space before tab is bad
endfunction

" TODO: disable/enable EOL-space error while typing (?)
cscope add /repo/hans/slask/.git/cscope.out /repo/hans/slask

function! g:ToggleListCharsEOL()
  let oldval = &listchars
  if match(oldval, 'eol') > -1
    exec 'set listchars-=eol:$'
  else
    exec 'set listchars+=eol:$'
  endif
endfunction

nnoremap <F12> :set hls!<CR>
inoremap <F12> <C-o>:set hls!<CR>
nnoremap <expr> <S-F12> g:ToggleListCharsEOL()
inoremap <expr> <S-F12> g:ToggleListCharsEOL()
nnoremap <C-F12> :set spell!<CR>
inoremap <C-F12> <C-o>:set spell!<CR>
nnoremap <F11> :setlocal number!<CR>
nnoremap <S-F11> :setlocal relativenumber!<CR>
nnoremap <C-F11> :setlocal wrap!<CR>

nnoremap <C-S-F11> :setlocal buftype=nofile<CR>

nnoremap <F9> :make!<CR>
inoremap <F9> <C-o>:make!<CR><CR>
nnoremap <F7> :cprev<CR>
inoremap <F7> <C-o>:cprev<CR>
nnoremap <F8> :cnext<CR>
inoremap <F8> <C-o>:cnext<CR>

map <F2>g :cs find g <cword><CR>
map <F2>s :cs find s <cword><CR>
map <F2>c :cs find c <cword><CR>
map <F2>t :cs find t <cword><CR>
map <F2>d :cs find d <cword><CR>

map <Leader>G :tab split +:Ggrep\ <cword><CR>
map <Leader>g :tab split +:Ggrep\\\ 

map <F3> :call DmenuOpen("edit")<CR>
map <S-F3> :call DmenuOpen("vsplit")<CR>
map <C-F3> :call DmenuOpen("tabedit")<CR>
map <F4> :call DmenuTag("tag")<CR>
map <S-F4> :call DmenuTag("tjump")<CR>

map <F6> :let kalle="vert stag ".expand('<cword>')<CR>:exec kalle<CR>
map <S-F6> :let kalle="tab stag ".expand('<cword>')<CR>:exec kalle<CR>

cmap <F8> <C-r>=g:GitTop<CR>

nnoremap <S-F7> :set foldlevel-=1<CR>
nnoremap <S-F8> :set foldlevel+=1<CR>
nnoremap <C-S-F7> :set foldlevel=0<CR>
nnoremap <C-S-F8> :set foldlevel=99<CR>

"For Emacs-style editing on the command-line: >
cnoremap <C-A> <Home>
cnoremap <C-B> <Left>
cnoremap <C-D> <Del>
cnoremap <C-E> <End>
cnoremap <C-F> <Right>
cnoremap <C-N> <Down>
cnoremap <C-P> <Up>
cnoremap <Esc><C-B> <S-Left>
cnoremap <Esc><C-F> <S-Right>

function! GetDmenuVersion(cmd)
  let tmp = system(a:cmd . " -v")
  if v:shell_error != 0
    return [0, 0]
  else
    let tmp2 = substitute(tmp, "^dmenu-", "", "")
    return [str2nr(tmp2[0]), str2nr(tmp2[2])]
  endif
endfunction

function! GetDmenuOptions()
  if g:dmenuversion[0] >= 4 && g:dmenuversion[1] >= 7
    return " -i -l 50 -p '' -w " . v:windowid
  else
    return " -i -l 50 -p ''"
  endif
endfunction

let system_dmenu_path = "dmenu"
let local_dmenu_path = expand("<sfile>:h:h") . "/submodules/dmenu/dmenu"

let system_dmenu_version = GetDmenuVersion(system_dmenu_path)
let local_dmenu_version = GetDmenuVersion(local_dmenu_path)

let g:dmenucmd="false"
if system_dmenu_version[0] == local_dmenu_version[0]
  if system_dmenu_version[1] == local_dmenu_version[1]
    if system_dmenu_version[0] == 0 && system_dmenu_version[1] == 0
      " versions are equal and = 0.0. no dmenu available :(
      let g:dmenucmd="false"
    else
      " versions are equal and both are runnable. pick system dmenu
      let g:dmenucmd=system_dmenu_path | let g:dmenuversion=system_dmenu_version
    endif
  elseif system_dmenu_version[1] > local_dmenu_version[1]
    let g:dmenucmd=system_dmenu_path | let g:dmenuversion=system_dmenu_version
  else
    let g:dmenucmd=local_dmenu_path | let g:dmenuversion=local_dmenu_version
  endif
elseif system_dmenu_version[0] > local_dmenu_version[0]
  let g:dmenucmd=system_dmenu_path | let g:dmenuversion=system_dmenu_version
else
  let g:dmenucmd=local_dmenu_path | let g:dmenuversion=local_dmenu_version
endif

vnoremap <Leader>f          <Esc>:call SearchForVisualSelection(0)<CR>
vnoremap <Leader>F          <Esc>:call SearchForVisualSelection(1)<CR>
function! SearchForVisualSelection(backward)
  let [l:lnum1, l:col1] = getpos("'<")[1:2]
  let [l:lnum2, l:col2] = getpos("'>")[1:2]
  if lnum1 != lnum2
    echohl ErrorMsg
    echo 'Multiple lines marked'
    echohl None
    return
  endif

  let l:sel = getline(lnum1)[ col1 - 1 : col2 - 1]
  let l:searchchar = '/'
  if a:backward == 1
    let l:searchchar = '?'
    call cursor(l:lnum1, l:col1)
  endif

  " feedkeys() inputs gets evaluated after a function returns so it can be used
  " to get around the ":help function-search-undo" problem which is that
  " last-search pattern and last-search direction is reset when returning
  " from a function.
  " using ":normal /pat<CR>" did not work and neither did search() and/or
  " assigning to the "/ register.
  call feedkeys(l:searchchar . l:sel . "\<CR>")
endfunction

set includeexpr=g:IncludeExprExample(v:fname)
function! g:IncludeExprExample(in)
  let top = g:GitTopLevel()
  let t2=substitute(a:in,'^b/',top,'g')
  let t=substitute(t2,'^a/',top,'g')
"  let t2=substitute(t,'^/',top . '/','g')
  return t2
endfunction

" Find a tag and pass it to cmd
function! DmenuTag(cmd)
  if g:dmenucmd == 'false'
    echom "Dmenu not found"
    return
  endif
  let top = g:GitTopLevel()
  let fname = system("set -o pipefail ; ~/configs/c-programs/dumptags -t " . top . "/.git/tags -l | " . g:dmenucmd . g:GetDmenuOptions())
  if v:shell_error != 0
    return
  endif

"  Xlib:  extension "XINERAMA" missing on display ":1011.0"
  let fname2 = substitute(fname, '\n$', '', '')
  " first substitute in the case of two "lines" (<CR> or NULL character present at the end)
  let fname = substitute(fname2, "Xlib:  extension \"XINERAMA\" missing.*\".*.\"\..", '', '')
  " the first pattern will not cover the case of one line, hence another substitute
  let fname = substitute(fname, "Xlib:  extension \"XINERAMA\" missing.*\".*.\"\.", '', '')

  if empty(fname)
    return
  endif

  execute a:cmd . " " . split(fname, " ")[0]
endfunction

" Find a file and pass it to cmd
function! DmenuOpen(cmd)
  if g:dmenucmd == 'false'
    echom "dmenu not found"
    return
  endif
  let top = g:GitTopLevel()
  echom top
  let fname = system("set -o pipefail ; git ls-files --full-name " . top . " | " . g:dmenucmd . g:GetDmenuOptions())
  if v:shell_error != 0
    echo 'dmenu exited with non-zero status'
    return
  endif

"  Xlib:  extension "XINERAMA" missing on display ":1011.0"
  let fname2 = substitute(fname, '\n$', '', '')
  " first substitute in the case of two "lines" (<CR> or NULL character present at the end)
  let fname = substitute(fname2, "Xlib:  extension \"XINERAMA\" missing.*\".*.\"\..", '', '')
  " the first pattern will not cover the case of one line, hence another substitute
  let fname = substitute(fname, "Xlib:  extension \"XINERAMA\" missing.*\".*.\"\.", '', '')

  if empty(fname)
    return
  endif
  execute a:cmd . " " . top . "/" . fname
endfunction

" get git top-level dir
function! g:GitTopLevel()
  " systemlist() seems like a convenient way to get rid of the newline in the
  " output from the git command
  let git_output = systemlist("git rev-parse --show-toplevel")
  if v:shell_error == 0
    return git_output[0]
  endif
  return ''
endfunction

function! g:GitUniqueId()
  let git_output = systemlist("git remote get-url origin")
  if v:shell_error == 0
    return git_output[0]
  endif
  return ''
endfunction

function! g:SetUpLocalRepoOptions(options)
  " Here we do stuff!
  " XXX figure out what the options struct should contain.
  "     > probably it should map repo fetch urls to vim options
  "       and/or vim commands.
  "     > maybe run the commands using :sandbox for extra safety!
endfunction

let g:GitTop = g:GitTopLevel()
if g:GitTop != ''
  exec 'set path+=' . g:GitTop
endif

function! g:IsMergetool()
  if &diff == 0
    return 0
  endif
  if match(argv(0), 'LOCAL') == -1
    return 0
  endif
  if argc() == 3
    if match(argv(1), 'REMOTE') == -1
      return 0
    endif
  elseif argc() == 4
    if match(argv(1), 'BASE') == -1
      return 0
    endif
    if match(argv(2), 'REMOTE') == -1
      return 0
    endif
  else
    return 0
  endif
  return 1
endfunction

function! g:SetupMergetool()
  " assume we are in the "MERGED" window when this function is called
  nnoremap <F9> :diffget LOCAL<CR>
  nnoremap <F10> :diffget BASE<CR>
  nnoremap <F11> :diffget REMOTE<CR>
  setlocal statusline=%<%f\ %h%m%r%=F9=LOCAL\ F10=BASE\ F11=REMOTE\ [%n/%{len(filter(range(1,bufnr('$')),'buflisted(v:val)'))}]\ %-14.(%l,%c%V%)\ %P
  vimgrep /=======/ %
endfunction

if g:IsMergetool()
  " postpone setup until windows are layed out correctly
  autocmd VimEnter * call g:SetupMergetool()
endif
