#!/bin/bash

set -f
FILEPATTERNS=(
  *.asm
  *.cpp
  *.hpp
  *.sig
  *.c
  *.h
  *.cc
  *.py
)
set +f

GITTOP=$(git rev-parse --show-toplevel)
if [ "$?" != 0 -o "$GITTOP"x == x ]; then
  echo Please enter a git repo first
  exit 1
fi

echo Building index for the following file patterns: "${FILEPATTERNS[@]}"

GIT_COMMIT=$(git show-ref --head --heads HEAD -s)

CSCOPE=$(which cscope)
CSCOPE_RETVALUE=$?

CTAGS=$(which ctags)
CTAGS_RETVALUE=$?

#this is fed to into the git submodule foreach command
printf -v QUOTED_PATTERNS "%q " "${FILEPATTERNS[@]}"
FOREACH_CMD="git ls-files $QUOTED_PATTERNS"

export GITTOP
if [ $CSCOPE_RETVALUE == 0 ]; then

	:
  #time git ls-files ${GITTOP}/*.asm ${GITTOP}/*.[ch]pp ${GITTOP}/*.sig ${GITTOP}/*.[ch] ${GITTOP}/*.cc | cscope -k -b -u -q -f ${GITTOP}/.git/cscope.out -i -
  #git ls-files "${FILEPATTERNS[@]/#/${GITTOP}/}" | cscope -k -b -u -q -f ${GITTOP}/.git/cscope.out -i -
  #echo ${GIT_COMMIT} > ${GITTOP}/.git/cscope.githash
fi

# TODO check for correct version of ctags
# TODO add support for git submodules
# - do not sort until all stuff are appended. will improve performance tons.
# TODO incremental updates!
# - maybe do it using multiple tags files to avoid sorting a really huge tag file
# - investigtae how vim handles that performance-wise
if [ $CTAGS_RETVALUE == 0 ]; then
  # looks like submodules are working now. printf %q FTW!
  git submodule foreach --recursive "${FOREACH_CMD} | ctags --tag-relative=yes --totals --sort=no --append -L - -o ${GITTOP}/.git/tags" 2>&1 | {
    read entering repo
    while [ "$entering"x == "Entering"x ]; do
	    read files _ lines kb _ _ _ seconds
	    if [ "$files"x == "Entering"x ]; then
		    entering=Entering
		    continue
	    fi
	    read tags
	    read _
	    read entering
    done
    echo Repo: $repo Files: $files
  }
  git ls-files "${FILEPATTERNS[@]/#/${GITTOP}/}" | ctags --tag-relative=yes --totals --sort=yes --append -L - -o ${GITTOP}/.git/tags
  echo ${GIT_COMMIT} > ${GITTOP}/.git/tags.githash
fi

