#!/bin/bash

FILEPATTERNS=(
  "*.asm"
  "*.cpp"
  "*.hpp"
  "*.sig"
  "*.c"
  "*.h"
  "*.cc"
  "*.py"
)

GITTOP=$(git rev-parse --show-toplevel)
if [ "$?" != 0 -o "$GITTOP"x == x ]; then
  echo Please enter a git repo first
  exit 1
fi

echo Building index for the following file patterns: "${FILEPATTERNS[@]}"

P2=("${FILEPATTERNS[@]/#/${GITTOP}/}")


PAT=("${FILEPATTERNS[@]/#/./}")
P=${PAT[*]}

echo P: "$P"

GIT_COMMIT=$(git show-ref --head --heads HEAD -s)

CSCOPE=$(which cscope)
CSCOPE_RETVALUE=$?

CTAGS=$(which ctags)
CTAGS_RETVALUE=$?

# set -f gets rid of globbing. awesome!
printf -v SUBCMD "git ls-files ${P}"
echo "$SUBCMD"

export GITTOP
export P
if [ $CSCOPE_RETVALUE == 0 ]; then
  #time git ls-files ${GITTOP}/*.asm ${GITTOP}/*.[ch]pp ${GITTOP}/*.sig ${GITTOP}/*.[ch] ${GITTOP}/*.cc | cscope -k -b -u -q -f ${GITTOP}/.git/cscope.out -i -
  time git ls-files "${PAT[@]}" | cscope -k -b -u -q -f ${GITTOP}/.git/cscope.out -i -
  echo ${GIT_COMMIT} > ${GITTOP}/.git/cscope.githash
fi

# TODO check for correct version of ctags
# TODO add support for git submodules
# - do not sort until all stuff are appended. will improve performance tons.
# TODO incremental updates!
# - maybe do it using multiple tags files to avoid sorting a really huge tag file
# - investigtae how vim handles that performance-wise
if [ $CTAGS_RETVALUE == 0 ]; then
  # XXX submodules needs some work. cant seem to be able to export array variables into the /bin/sh subshell of git foreach
  git submodule foreach --recursive "set -f; ${SUBCMD}" # | ctags --tag-relative=yes --totals --sort=no --append --langmap=c:.c.sig -L - -o ${GITTOP}/.git/tags'
  git ls-files "${P2[@]}" | ctags --tag-relative=yes --totals --append -L - -o ${GITTOP}/.git/tags
  echo ${GIT_COMMIT} > ${GITTOP}/.git/tags.githash
fi

